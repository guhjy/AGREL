{
    "collab_server" : "",
    "contents" : "#' Agreement matrix\n#'\n#' Function to compute an agreement matrix containing the specific agreements and the conditional probabilities indicative\n#' of confusion between categories. The overall proportion of agreement is also calculated.\n#'\n#' @param df A dataframe or matrix of N x P with N the number of observations and P the number of raters.\n#' @param CI Logical, indicates if confidence intervals using bootstrapping have to be calculated.\n#' @param alpha Alpha-level for the confidence intervals.\n#' @param NrBoot Number of bootstrap samples.\n#' @param Parallel Logical, indicates if parallel computing has to be used.\n#' @param no_cores Number of cores if parallel computing is used. Default is 1 core less than the number of\n#' cores present.\n#' @param na.rm Logical, indicates if NaN must be removed from the bootstrapsamples.\n#'\n#' @return A list with the following components:\n#' @return \\item{PAMatrix}{A matrix containing the specific agreements on the diagonals and the confusion agreement\n#' on the off-diagonal elements.}\n#' @return \\item{nraters}{Number of raters}\n#' @return \\item{N}{Sample size}\n#' @return \\item{data}{Original dataframe or matrix used as input}\n#' @export\n#'\n#' @references Uebersax, J.S. (1982). A design-independent method for measuring the reliability of psychiatric\n#' diagnosis. \\emph{Journal of Psychiatric Research}, Vol.17(4), pp.335-342\n#' @references Roberts C., Mcnamee R. (1998). A matrix of kappa-type coefficients to assess the reliability of\n#' nominal scales. \\emph{Statistics in medicine}, Vol.17(4), pp.471-88\n#'\n#' @examples\n#' # Load data\n#' data(PsychMorbid)\n#'\n#' # Function\n#' AgreemGeneralized(PsychMorbid)\nAgreemGeneralized <- function(df, CI=F, alpha = 0.05, NrBoot = 1e3, Parallel = F, no_cores = detectCores()-1, na.rm=F){\n  if(is.matrix(df)) df = as.data.frame(df)\n  if(!is.data.frame(df)) stop(\"Must be of type dataframe.\")\n  UniqValues  = as.character(unique(unlist(df)))\n  if(length(UniqValues)==1) stop(\"Only one unique value.\")\n  if(any(table(unlist(df))<10)){\n    warning(\"The frequency of some levels of the variable are very low\", immediate. = T)\n    LowPrev = names(table(unlist(df)))[table(unlist(df))<10]\n  }else{\n    LowPrev = NULL\n  }\n\n  R           = ncol(df)\n  N           = nrow(df)\n  c           = length(UniqValues)\n  PAMatrix    = matrix(NA,c,c)\n  colnames(PAMatrix) <- rownames(PAMatrix) <- UniqValues\n  S           = NULL\n  Ps          = NULL\n  if(CI) PsCI = matrix(NA, c + 1, 3) else PsCI = NULL\n\n  for(j in UniqValues){\n    Pj    = sum(apply(df,1,function(x) sum(x==j)))/(N*R)\n    S[j]  = sum(apply(df,1,function(x) sum(x==j)*(sum(x==j) - 1)))\n    Ps[j] = S[j]/sum(apply(df,1,function(x) sum(x==j)*(R - 1)))\n    PAMatrix[which(UniqValues==j),which(UniqValues==j)] = Ps[j]\n    if(CI & !j%in%LowPrev){\n      if(!Parallel){\n        BtPAMat <- function(df, j){\n          df.bt       = df[sample(1:nrow(df),nrow(df),T),]\n          R           = ncol(df.bt)\n          N           = nrow(df.bt)\n          S           = NULL\n          Ps          = NULL\n\n          S           = sum(apply(df.bt,1,function(x) sum(x==j)*(sum(x==j) - 1)))\n          Ps          = S/sum(apply(df.bt,1,function(x) sum(x==j)*(R - 1)))\n          return(Ps)\n        }\n        BtSamples    = replicate(NrBoot, BtPAMat(df, j))\n      }else{\n        cl       = makeCluster(no_cores)\n        clusterExport(cl,c(\"df\",\"j\"), envir = environment())\n        BtSamples = parSapply(cl, 1:NrBoot,function(y){\n          df.bt       = df[sample(1:nrow(df),nrow(df),T),]\n          R           = ncol(df.bt)\n          N           = nrow(df.bt)\n          S           = NULL\n          Ps          = NULL\n\n          S           = sum(apply(df.bt,1,function(x) sum(x==j)*(sum(x==j) - 1)))\n          Ps          = S/sum(apply(df.bt,1,function(x) sum(x==j)*(R - 1)))\n          return(Ps)\n        })\n        stopCluster(cl)\n      }\n      if(anyNA(BtSamples)) warning(paste(\"NaN's present in \", sum(is.na(BtSamples)), \"bootstrapsamples for\", j), immediate.=T)\n      CIs          = quantile(BtSamples, c(alpha/2, 1 - alpha/2), na.rm = na.rm)\n      PsCI[which(UniqValues==j),] = c(LowerCI = CIs[1], SpecificAgreem = Ps[j], UpperCI=CIs[2])\n    }\n    if(CI & j%in%LowPrev) PsCI[which(UniqValues==j),2] = Ps[j]\n\n    for(k in UniqValues){\n      if(j!=k){\n        Pk   = sum(apply(df,1,function(x) sum(x==k)))/(N*R)\n        Kjk  = (Pj*Pk - (sum(apply(df,1,function(x) sum(x==j)*sum(x==k)))/(R*(R-1)*N)))/(Pj*Pk)\n        Pjk  = Pj*(1-Kjk)\n        PAMatrix[which(UniqValues==j),which(UniqValues==k)] = Pjk\n      }\n    }\n  }\n  Oposs          = R*(R-1)*N\n  Po             = sum(S)/Oposs\n\n  if(CI){\n    if(!Parallel){\n        BtOverAgr <- function(df){\n        df.bt       = df[sample(1:nrow(df),nrow(df),T),]\n        UniqValues  = as.character(unique(unlist(df.bt)))\n        R           = ncol(df.bt)\n        N           = nrow(df.bt)\n        S           = NULL\n        for(j in UniqValues){\n          Pj    = sum(apply(df.bt,1,function(x) sum(x==j)))/(N*R)\n          S[j]  = sum(apply(df.bt,1,function(x) sum(x==j)*(sum(x==j) - 1)))\n        }\n        Oposs          = R*(R-1)*N\n        Po             = sum(S)/Oposs\n        return(Po)\n      }\n      BtSamples         = replicate(NrBoot, BtOverAgr(df))\n    }else{\n      cl       = makeCluster(no_cores)\n      clusterExport(cl,c(\"df\"), envir = environment())\n      BtSamples = parSapply(cl, 1:NrBoot,function(y){\n        df.bt       = df[sample(1:nrow(df),nrow(df),T),]\n        UniqValues  = as.character(unique(unlist(df.bt)))\n        R           = ncol(df.bt)\n        N           = nrow(df.bt)\n        S           = NULL\n        for(j in UniqValues){\n          Pj    = sum(apply(df.bt,1,function(x) sum(x==j)))/(N*R)\n          S[j]  = sum(apply(df.bt,1,function(x) sum(x==j)*(sum(x==j) - 1)))\n        }\n        Oposs          = R*(R-1)*N\n        Po             = sum(S)/Oposs\n        return(Po)\n      })\n      stopCluster(cl)\n    }\n    if(anyNA(BtSamples)) warning(paste(\"NaN's present in \", sum(is.na(BtSamples)), \"bootstrapsamples for calculating the overall agreement\"),immediate.=T)\n    CIs               = quantile(BtSamples, c(alpha/2, 1 - alpha/2), na.rm = na.rm)\n    PsCI[nrow(PsCI),] = c(CIs[1], Po, CIs[2])\n    colnames(PsCI)    = c(\"LowerCI\",\"SpecificAgreem\",\"UpperCI\")\n    rownames(PsCI)    = c(UniqValues,\"OverallAgreement\")\n  }\n\n\n  Results        = list(OverallAgreement = Po, PAMatrix=PAMatrix, SpecificAgreemCI = PsCI, nraters = R, N = N, data = df)\n  Results        = Results[!unlist(lapply(Results, is.null))]\n  class(Results) = append(class(Results), \"AgreemGeneralized\")\n  return(Results)\n}\n",
    "created" : 1491590251935.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "840065055",
    "id" : "595EEC7E",
    "lastKnownWriteTime" : 1492005959,
    "last_content_update" : 1492005959,
    "path" : "C:/Users/u0095171/Google Drive/werk UZ Leuven_acer/Statistical programs/R/packages R/building packages/AGREL/R/PA.Matrix.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}