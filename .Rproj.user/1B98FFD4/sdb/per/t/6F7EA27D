{
    "collab_server" : "",
    "contents" : "#' Matrix of Kappa-type coefficients\n#'\n#' Function to compute a matrix of kappa-type coefficients to assess the reliability of nominal variables\n#' (Roberts & McNamee, 1998).\n#'\n#' @param df A dataframe or matrix of N x P with N the number of observations and P the number of raters.\n#' @param FleissKappa Logical, indicates if Fleiss' Kappa has to be calculated.\n#' @param CI.est Logical, indicates if confidence intervals using bootstrapping have to be calculated.\n#' @param N.bt Number of bootstrap samples.\n#' @param parallel Logical, indicates if parallel computing has to be used.\n#' @param NrCores Number of cores if parallel computing is used. Default is 1 core less than the number of\n#' cores present.\n#'\n#' @return A list containing the kappa-matrix and Fleiss' Kappa if asked for.\n#' @references Roberts C., McNamee R. (1998). A matrix of kappa-type coefficients to assess the reliability of\n#' nominal scales. \\emph{Statistics in medicine}, Vol.17(4), pp.471-88\n#'\n#' @examples\n#' data(PsychMorbid)\n#' Kappa.Matrix(PsychMorbid)\nKappa.Matrix <- function(df,FleissKappa=F,CI.est=F,N.bt=1e3,parallel=F,NrCores=detectCores - 1){\nif(is.matrix(df)) df = as.data.frame(df)\nif(!is.data.frame(df)) stop(\"Must be of type dataframe.\")\nUniqValues <- as.character(unique(unlist(df)))\nif(length(UniqValues)==1) stop(\"Only one unique value.\")\nif(!parallel){\nR <- ncol(df)\nN <- nrow(df)\nc <- length(UniqValues)\nKappaMatrix <- matrix(NA,c,c)\nMinLambda = matrix(NA,c,c)\nMaxLambda = matrix(NA,c,c)\ncolnames(KappaMatrix) <- rownames(KappaMatrix) <- UniqValues\ncolnames(MinLambda) = rownames(MinLambda) = UniqValues\ncolnames(MaxLambda) = rownames(MaxLambda) = UniqValues\n\nfor(j in UniqValues){\n  # Kappa coefficients Kj\n  Pj <- sum(apply(df,1,function(x) sum(x==j)))/(N*R)\n  Kj <- ((sum(apply(df,1,function(x) sum(x==j)*(sum(x==j) - 1)))/(R*(R-1)*N)) - Pj^2)/(Pj*(1-Pj))\n    # CI\n    if(CI.est){\n      Bt.j <- j\n      BtResKj <- replicate(N.bt,BtSamples(df,fun=function(z,j=Bt.j){\n        Pj <- sum(apply(z,1,function(x) sum(x==j)))/(N*R)\n        Kj <- ((sum(apply(z,1,function(x) sum(x==j)*(sum(x==j) - 1)))/(R*(R-1)*N)) - Pj^2)/(Pj*(1-Pj))\n        return(Kj)\n      }))\n      CI <- quantile(BtResKj,c(0.025,0.975))\n      Kj <- paste(round(Kj,3),\" (\",round(CI[1],3),\" to \",round(CI[2],3),\")\",sep=\"\")\n    }\n  KappaMatrix[which(UniqValues==j),which(UniqValues==j)] <- Kj\n\n\n  # Off-diagonal elements\n  for(k in UniqValues){\n    Pk <- sum(apply(df,1,function(x) sum(x==k)))/(N*R)\n    if(which(UniqValues==j)<which(UniqValues==k)){\n      CorrCoef = F\n      Kjk <- (Pj*Pk - (sum(apply(df,1,function(x) sum(x==j)*sum(x==k)))/(R*(R-1)*N)))/(Pj*Pk)\n      KappaMatrix[which(UniqValues==j),which(UniqValues==k)] <- Kjk\n    }else if(which(UniqValues==j)>which(UniqValues==k)){\n      CorrCoef = T\n      Lambda_jk <- ((sum(apply(df,1,function(x) sum(x==j)*sum(x==k)))/(R*(R-1)*N)) - Pj*Pk)/(sqrt(Pj*(1-Pj)*Pk*(1-Pk)))\n      KappaMatrix[which(UniqValues==j),which(UniqValues==k)] <- Lambda_jk\n      MinLambda_jk = - ((Pj * Pk)/((1 - Pj) * (1 - Pk)))^0.5\n      MaxLambda_jk = ((Pj * (1 - Pk))/(Pk * (1 - Pj)))^0.5\n      MinLambda[which(UniqValues==j),which(UniqValues==k)] = MinLambda_jk\n      MaxLambda[which(UniqValues==j),which(UniqValues==k)] = MaxLambda_jk\n    }\n    # CI\n    if(CI.est & j!=k){\n     Bt.k <- k\n     Pj.o <- Pj\n     BtResOffD <- replicate(N.bt,BtSamples(df,fun=function(z,j=Bt.j,k=Bt.k,Lambda=CorrCoef){\n       Pj <- sum(apply(z,1,function(x) sum(x==j)))/(N*R)\n       Pk <- sum(apply(z,1,function(x) sum(x==k)))/(nrow(z)*ncol(z))\n       if(!Lambda) return((Pj*Pk - (sum(apply(z,1,function(x) sum(x==j)*sum(x==k)))/(R*(R-1)*N)))/(Pj*Pk))\n       if(Lambda) return(((sum(apply(z,1,function(x) sum(x==j)*sum(x==k)))/(R*(R-1)*N)) - Pj*Pk)/(sqrt(Pj*(1-Pj)*Pk*(1-Pk))))\n     }))\n     CI2 <- quantile(BtResOffD,c(0.025,0.975),na.rm=T)\n     if(!CorrCoef){\n       KappaMatrix[which(UniqValues==j),which(UniqValues==k)] <- paste(round(Kjk,3),\" (\",round(CI2[1],3),\" to \",\n                                                                                         round(CI2[2],3),\")\",sep=\"\")\n     }else if(CorrCoef){\n       KappaMatrix[which(UniqValues==j),which(UniqValues==k)] <- paste(round(Lambda_jk,3),\" (\",round(CI2[1],3),\" to \",\n                                                                                        round(CI2[2],3),\")\",sep=\"\")\n     }\n    }\n  }\n}\n}else{\nKappaMatrix <- KappaMPar(df,CI.est=CI.est,N.bt=N.bt)\n}\nif(FleissKappa) Fl.k <- FleissK(df)[3]\nif(!parallel){\nif(FleissKappa) return(list(FleissKappa = Fl.k,KappaMatrix = KappaMatrix, MinLambda = MinLambda, MaxLambda = MaxLambda))\n  else return(list(KappaMatrix = KappaMatrix, MinLambda = MinLambda, MaxLambda = MaxLambda))\n}else{\n  return(KappaMatrix)\n}\n}\n\n\n\n\n\n\n\n",
    "created" : 1499246434519.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2170584002",
    "id" : "6F7EA27D",
    "lastKnownWriteTime" : 1499247249,
    "last_content_update" : 1499247249794,
    "path" : "C:/Users/u0095171/Google Drive/werk UZ Leuven_acer/Statistical programs/R/packages R/building packages/AGREL_Github/R/KappaMatrix.R",
    "project_path" : "R/KappaMatrix.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}